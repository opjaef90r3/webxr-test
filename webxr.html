<!DOCTYPE html>
<html>
  <head>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>
    <script>
      // Gun component
      AFRAME.registerComponent('gun', {
        init: function () {
          this.shooting = false;
          this.currentFireMode = 'semi'; // 'semi', 'burst', 'auto'
          this.burstCount = 0;
          this.lastShootTime = 0;
          this.ammo = 30;
          this.maxAmmo = 30;
          this.el.addEventListener('triggerdown', this.onTriggerDown.bind(this));
          this.el.addEventListener('triggerup', this.onTriggerUp.bind(this));
          this.el.addEventListener('bbuttondown', this.toggleFireMode.bind(this));
          this.updateAmmoDisplay();
        },
        onTriggerDown: function () {
          this.shooting = true;
          this.shoot();
        },
        onTriggerUp: function () {
          this.shooting = false;
          this.burstCount = 0;
        },
        toggleFireMode: function () {
          const modes = ['semi', 'burst', 'auto'];
          const currentIndex = modes.indexOf(this.currentFireMode);
          this.currentFireMode = modes[(currentIndex + 1) % modes.length];
          console.log('Fire mode: ' + this.currentFireMode);
        },
        shoot: function () {
          if (!this.shooting || this.ammo <= 0) return;
          
          const now = Date.now();
          if (now - this.lastShootTime < 100) return; // Rate of fire limit
          
          this.lastShootTime = now;
          this.ammo--;
          this.updateAmmoDisplay();
          
          this.el.emit('shoot');
          
          if (this.currentFireMode === 'semi') {
            this.shooting = false;
          } else if (this.currentFireMode === 'burst') {
            this.burstCount++;
            if (this.burstCount >= 3) {
              this.shooting = false;
              this.burstCount = 0;
            }
          }
          
          if (this.shooting) {
            setTimeout(() => this.shoot(), this.currentFireMode === 'auto' ? 100 : 50);
          }
        },
        updateAmmoDisplay: function () {
          const ammoDisplay = document.querySelector('#ammoDisplay');
          if (ammoDisplay) {
            ammoDisplay.setAttribute('value', `Ammo: ${this.ammo}/${this.maxAmmo}`);
          }
        }
      });

      // Pickable component
      AFRAME.registerComponent('pickable', {
        schema: {
          hand: {type: 'selector'}
        },
        init: function () {
          this.el.addEventListener('gripdown', this.onGripDown.bind(this));
          this.el.addEventListener('gripup', this.onGripUp.bind(this));
          this.originalParent = this.el.parentNode;
          this.originalPosition = this.el.getAttribute('position');
          this.originalRotation = this.el.getAttribute('rotation');
        },
        onGripDown: function () {
          const handPosition = new THREE.Vector3();
          this.data.hand.object3D.getWorldPosition(handPosition);
          const distance = this.el.object3D.position.distanceTo(handPosition);
          
          if (distance < 0.5) {  // If hand is close enough
            this.el.setAttribute('visible', true);
            this.data.hand.appendChild(this.el);
            this.el.setAttribute('position', '0 0 -0.25');
            this.el.setAttribute('rotation', '0 0 0');
          }
        },
        onGripUp: function () {
          this.originalParent.appendChild(this.el);
          this.el.setAttribute('position', this.originalPosition);
          this.el.setAttribute('rotation', this.originalRotation);
        },
        tick: function() {
          if (this.el.parentNode === this.originalParent) {
            this.el.setAttribute('position', this.originalPosition);
            this.el.setAttribute('rotation', this.originalRotation);
          }
        }
      });

      // Target component
      AFRAME.registerComponent('target', {
        schema: {
          health: {type: 'int', default: 100}
        },
        init: function () {
          this.currentHealth = this.data.health;
          this.el.addEventListener('hit', this.onHit.bind(this));
        },
        onHit: function (evt) {
          this.currentHealth -= 10;
          if (this.currentHealth <= 0) {
            this.el.setAttribute('visible', 'false');
            document.querySelector('#score').setAttribute('value', parseInt(document.querySelector('#score').getAttribute('value')) + 1);
            setTimeout(() => {
              this.currentHealth = this.data.health;
              this.el.setAttribute('visible', 'true');
            }, 2000);
          } else {
            // Visual feedback for hit
            this.el.setAttribute('material', 'color', 'red');
            setTimeout(() => {
              this.el.setAttribute('material', 'color', 'blue');
            }, 100);
          }
        }
      });

      // Bullet component
      AFRAME.registerComponent('bullet', {
        init: function () {
          this.el.addEventListener('collide', this.onCollide.bind(this));
          setTimeout(() => {
            if (this.el.parentNode) {
              this.el.parentNode.removeChild(this.el);
            }
          }, 5000);  // Bullet lifespan
        },
        onCollide: function (evt) {
          if (evt.detail.body.el.getAttribute('target')) {
            evt.detail.body.el.emit('hit');
          }
          this.el.parentNode.removeChild(this.el);
        }
      });

      // Sound generator component
      AFRAME.registerComponent('sound-generator', {
        init: function () {
          this.audioContext = null;
          this.isInitialized = false;
          document.body.addEventListener('click', () => this.initAudio(), { once: true });
        },
        initAudio: function () {
          if (this.isInitialized) return;
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.isInitialized = true;
        },
        playShootSound: function () {
          if (!this.isInitialized) return;
          const oscillator = this.audioContext.createOscillator();
          oscillator.type = 'square';
          oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
          
          const gainNode = this.audioContext.createGain();
          gainNode.gain.setValueAtTime(1, this.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          oscillator.start();
          oscillator.stop(this.audioContext.currentTime + 0.2);
        },
        playHitSound: function () {
          if (!this.isInitialized) return;
          const oscillator = this.audioContext.createOscillator();
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(880, this.audioContext.currentTime);
          
          const gainNode = this.audioContext.createGain();
          gainNode.gain.setValueAtTime(0.5, this.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          oscillator.start();
          oscillator.stop(this.audioContext.currentTime + 0.1);
        }
      });

      // Advanced movement component
      AFRAME.registerComponent('advanced-movement', {
        schema: {
          walkSpeed: {type: 'number', default: 2},
          runSpeed: {type: 'number', default: 5},
          jumpForce: {type: 'number', default: 5},
          height: {type: 'number', default: 1.6}
        },
        init: function () {
          this.velocity = new THREE.Vector3();
          this.acceleration = new THREE.Vector3();
          this.deceleration = new THREE.Vector3(-10, -9.8, -10);
          this.isRunning = false;
          this.canJump = true;
          
          this.el.addEventListener('thumbstickmoved', this.onThumbstickMoved.bind(this));
          this.el.addEventListener('abuttondown', this.onJump.bind(this));
          this.el.addEventListener('xbuttondown', this.toggleRun.bind(this));
          this.el.addEventListener('ybuttondown', this.adjustHeight.bind(this));
        },
        onThumbstickMoved: function (evt) {
          const x = evt.detail.x;
          const y = evt.detail.y;
          const speed = this.isRunning ? this.data.runSpeed : this.data.walkSpeed;
          this.acceleration.x = x * speed;
          this.acceleration.z = -y * speed;
        },
        onJump: function () {
          if (this.canJump) {
            this.velocity.y = this.data.jumpForce;
            this.canJump = false;
            setTimeout(() => { this.canJump = true; }, 1000);
          }
        },
        toggleRun: function () {
          this.isRunning = !this.isRunning;
          console.log(this.isRunning ? 'Running' : 'Walking');
        },
        adjustHeight: function () {
          const currentHeight = this.el.object3D.position.y;
          const newHeight = currentHeight === this.data.height ? this.data.height / 2 : this.data.height;
          this.el.object3D.position.y = newHeight;
          console.log(`Height adjusted to ${newHeight}`);
        },
        tick: function (time, timeDelta) {
          const deltaSeconds = timeDelta / 1000;
          const rotation = this.el.object3D.rotation;
          
          this.velocity.x += this.acceleration.x * deltaSeconds;
          this.velocity.y += this.acceleration.y * deltaSeconds;
          this.velocity.z += this.acceleration.z * deltaSeconds;
          
          this.velocity.x += this.deceleration.x * this.velocity.x * deltaSeconds;
          this.velocity.y += this.deceleration.y * deltaSeconds;
          this.velocity.z += this.deceleration.z * this.velocity.z * deltaSeconds;
          
          const movementVector = new THREE.Vector3(this.velocity.x, 0, this.velocity.z);
          movementVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.y);
          
          this.el.object3D.position.x += movementVector.x * deltaSeconds;
          this.el.object3D.position.y += this.velocity.y * deltaSeconds;
          this.el.object3D.position.z += movementVector.z * deltaSeconds;
          
          if (this.el.object3D.position.y < this.data.height) {
            this.el.object3D.position.y = this.data.height;
            this.velocity.y = 0;
            this.canJump = true;
          }
        }
      });
    </script>
  </head>
  <body>
    <a-scene physics="debug: true" sound-generator>
      <a-assets>
        <!-- Add any necessary assets here -->
      </a-assets>

      <!-- Player rig -->
      <a-entity id="rig" position="0 1.6 0" advanced-movement="walkSpeed: 2; runSpeed: 5; jumpForce: 5; height: 1.6">
        <a-entity camera look-controls></a-entity>
        <a-entity id="leftHand" oculus-touch-controls="hand: left"></a-entity>
        <a-entity id="rightHand" oculus-touch-controls="hand: right"></a-entity>
      </a-entity>

      <!-- Gun -->
      <a-entity id="gun" gun pickable="hand: #rightHand" position="0.5 1 -0.5">
        <a-box color="#4d4d4d" depth="0.2" height="0.3" width="0.1"></a-box>
        <a-cylinder color="#1a1a1a" radius="0.02" height="0.4" position="0 0.1 -0.25" rotation="90 0 0"></a-cylinder>
        <a-box color="#4d4d4d" depth="0.05" height="0.15" width="0.1" position="0 -0.1 0.05"></a-box>
        <a-entity id="bulletSpawn" position="0 0.15 -0.45"></a-entity>
      </a-entity>

      <!-- Environment -->
      <a-entity environment="preset: tron; groundColor: #0e172a; groundColor2: #162442; groundTexture: walkernoise; grid: 1x1; gridColor: #0c80ff; horizonColor: #3fb2ff; skyColor: #9ae3ff; lighting: distant"></a-entity>

      <!-- Targets -->
      <a-entity id="targetGroup" position="0 0 -10">
        <a-box class="target" target="health: 100" position="-2 1.5 0" depth="0.5" height="0.5" width="0.5" color="blue" animation="property: position; to: -2 1.5 -5; dur: 5000; dir: alternate; loop: true"></a-box>
        <a-sphere class="target" target="health: 150" position="0 2 -2" radius="0.4" color="green" animation="property: position; to: 0 2 2; dur: 4000; dir: alternate; loop: true"></a-sphere>
        <a-cylinder class="target" target="health: 200" position="2 1 0" radius="0.3" height="1" color="red" animation="property: rotation; to: 0 360 0; dur: 3000; loop: true"></a-cylinder>
      </a-entity>

      <!-- UI Elements -->
<!-- UI Elements (continued) -->
      <a-text id="score" value="Score: 0" position="-0.75 1.5 -2" scale="0.5 0.5 0.5" color="white"></a-text>
      <a-text id="ammoDisplay" value="Ammo: 30/30" position="0.75 1.5 -2" scale="0.5 0.5 0.5" color="white"></a-text>
      <a-text id="modeDisplay" value="Mode: Semi" position="0 1.7 -2" scale="0.5 0.5 0.5" color="white"></a-text>

      <!-- Additional Environment Objects -->
      <a-entity id="obstacles" position="0 0 -5">
        <a-box position="-3 0.5 0" width="1" height="1" depth="1" color="#45a5f5" animation="property: rotation; to: 0 360 0; loop: true; dur: 10000"></a-box>
        <a-torus position="3 1 0" radius="0.5" radius-tubular="0.1" color="#ff9800" animation="property: rotation; to: 360 360 0; loop: true; dur: 8000"></a-torus>
        <a-octahedron position="0 1.25 3" radius="0.5" color="#4caf50" animation="property: position; to: 0 2 3; dir: alternate; loop: true; dur: 2000"></a-octahedron>
      </a-entity>

      <!-- Lighting -->
      <a-light type="ambient" color="#ffffff" intensity="0.5"></a-light>
      <a-light type="directional" color="#ffffff" intensity="0.8" position="-1 1 1"></a-light>

      <!-- Particle systems for visual effects -->
      <a-entity position="0 2.25 -15" particle-system="preset: dust; particleCount: 2000; size: 0.5; color: #44ffff,#44ccff"></a-entity>
    </a-scene>

    <script>
      var scene = document.querySelector('a-scene');
      var gun = document.querySelector('#gun');
      var bulletSpawn = document.querySelector('#bulletSpawn');
      var soundGenerator = scene.components['sound-generator'];
      var score = 0;

      gun.addEventListener('shoot', function () {
        var bullet = document.createElement('a-sphere');
        bullet.setAttribute('dynamic-body', '');
        bullet.setAttribute('bullet', '');
        bullet.setAttribute('radius', '0.05');
        bullet.setAttribute('color', '#ffff00');
        bullet.setAttribute('emissive', '#ffff00');
        bullet.setAttribute('emissiveIntensity', '0.5');
        
        var pos = new THREE.Vector3();
        var rot = new THREE.Quaternion();
        bulletSpawn.object3D.getWorldPosition(pos);
        bulletSpawn.object3D.getWorldQuaternion(rot);

        bullet.setAttribute('position', pos);
        
        var direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(rot);
        direction.multiplyScalar(30);

        bullet.setAttribute('velocity', direction);
        scene.appendChild(bullet);
        soundGenerator.playShootSound();

        // Muzzle flash effect
        var muzzleFlash = document.createElement('a-entity');
        muzzleFlash.setAttribute('position', pos);
        muzzleFlash.setAttribute('particle-system', 'preset: spark; particleCount: 20; size: 0.2; color: #ffff00; blending: additive; maxAge: 0.1');
        scene.appendChild(muzzleFlash);
        setTimeout(() => scene.removeChild(muzzleFlash), 100);
      });

      scene.addEventListener('hit', function () {
        soundGenerator.playHitSound();
        score += 10;
        document.querySelector('#score').setAttribute('value', `Score: ${score}`);
      });

      // Reload function
      function reload() {
        var gunComponent = gun.components.gun;
        gunComponent.ammo = gunComponent.maxAmmo;
        gunComponent.updateAmmoDisplay();
        console.log('Reloaded');
      }

      // Add reload on 'Y' button press
      document.querySelector('#rightHand').addEventListener('ybuttondown', reload);

      // Update fire mode display
      gun.addEventListener('componentchanged', function(evt) {
        if (evt.detail.name === 'gun') {
          document.querySelector('#modeDisplay').setAttribute('value', `Mode: ${evt.detail.newData.currentFireMode}`);
        }
      });

      // Add some basic game loop logic
      var gameLoop = setInterval(function() {
        // Respawn targets that are not visible
        document.querySelectorAll('.target').forEach(function(target) {
          if (!target.getAttribute('visible')) {
            target.setAttribute('visible', 'true');
            target.components.target.currentHealth = target.components.target.data.health;
          }
        });

        // You could add more game logic here, such as:
        // - Spawning new targets
        // - Updating difficulty based on score
        // - Checking win/lose conditions
      }, 5000);  // Run every 5 seconds
    </script>
  </body>
</html>
